input {
    jdbc {
        jdbc_connection_string => "jdbc:postgresql://postgres:5432/search"
        jdbc_user => "search"
        jdbc_password => "admin"
        jdbc_driver_class => "org.postgresql.Driver"
        #jdbc_driver_library => "postgresql-42.2.12.jar"
        #SELECT keys.* FROM mytable, json_object_keys(mytable.data) AS keys (mykey);
        statement => 'SELECT r.uuid as id, CAST(data as text), s.id as source_id, s.name as source_name, (SELECT COUNT(*) from "references" WHERE source = r.source) AS source_total_count FROM "references" r LEFT JOIN sources s ON (r.source=s.id)' # WHERE last_modified > :sql_last_value'
        #tracking_column => scraped
        #tracking_column_type => "timestamp"
        #use_column_value => true

        ## every 30 seconds
        schedule => "/30 * * * * *"
        type => "search"
        lowercase_column_names => false
    }
}
filter {
    mutate {
        rename => {"source_id" => "[source][id]"}
        rename => {"source_name" => "[source][name]"}
        rename => {"source_total_count" => "[source][total_count]"}
    }
    json {
        source => "data"
    }
    prune {
        blacklist_names => [ "data", "type", "doc", "@version", "@timestamp" ]
    }
}
output {
    #stdout { }
    elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "search_idx"
        action => update
        document_id => "%{[id]}"
        doc_as_upsert => true
        #user => "elastic"
        #password => "changethisinproduction"
        template => "/usr/share/logstash/templates/elastic-index.json"
        template_name => "search_idx"
        template_overwrite => true
    }
}